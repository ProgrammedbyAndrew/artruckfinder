<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>AR Arrow Demo</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    font-family: sans-serif;
  }

  #videoElement {
    position: absolute;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    object-fit: cover;
    z-index: 1;
  }

  #threeContainer {
    position: absolute;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    z-index: 2;
    pointer-events: none;
  }

  #info {
    position: absolute;
    bottom: 10px; left: 10px;
    background: rgba(0,0,0,0.5);
    color: #fff; padding: 10px;
    font-size: 14px;
    z-index: 3;
    max-width: 80vw;
    word-wrap: break-word;
  }

  #debugConsole {
    position: absolute;
    top: 10px; right: 10px;
    width: 40vw; 
    max-height: 30vh;
    overflow-y: auto;
    background: rgba(0,0,0,0.8);
    color: #0f0;
    font-size: 12px;
    line-height: 1.2em;
    padding: 5px;
    z-index: 999;
    border: 1px solid #0f0;
    font-family: monospace;
  }

  #controls {
    position: absolute;
    top: 10px; left: 10px;
    z-index: 1000;
    display: flex;
    gap: 10px;
  }

  button {
    background: #222;
    color: #fff;
    border: 1px solid #0f0;
    font-size: 14px;
    padding: 5px;
    cursor: pointer;
  }
</style>
</head>
<body>

<video id="videoElement" autoplay playsinline></video>
<div id="threeContainer"></div>
<div id="info">Loading...</div>
<div id="debugConsole">Debug console initialized...</div>
<div id="controls">
  <button id="copyLogBtn">Copy Log</button>
  <button id="enableOrientationBtn" style="display:none;">Enable Orientation</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js"></script>

<script>
let logs = [];
function logMessage(...args) {
  console.log(...args); // keep original console
}

// Override console methods to also write to debug console
(function() {
  const debugEl = document.getElementById('debugConsole');

  function appendMessage(type, ...args) {
    const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
    const line = document.createElement('div');
    line.textContent = `[${type.toUpperCase()}] ${msg}`;
    debugEl.appendChild(line);
    debugEl.scrollTop = debugEl.scrollHeight;
    logs.push(`${type.toUpperCase()} ${msg}`);
  }

  const origLog = console.log;
  const origWarn = console.warn;
  const origErr = console.error;

  console.log = (...args) => { origLog(...args); appendMessage('log', ...args); };
  console.warn = (...args) => { origWarn(...args); appendMessage('warn', ...args); };
  console.error = (...args) => { origErr(...args); appendMessage('error', ...args); };

  window.onerror = (msg, source, lineno, colno, error) => {
    appendMessage('error', `Error: ${msg} at ${source}:${lineno}:${colno}`, error);
  };

  console.log("Debug console active.");
})();

// Copy log button
document.getElementById('copyLogBtn').addEventListener('click', () => {
  const text = logs.join('\n');
  navigator.clipboard.writeText(text).then(() => {
    console.log("Log copied to clipboard.");
  });
});

// Orientation permission (for iOS)
const enableOrientationBtn = document.getElementById('enableOrientationBtn');
if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
  enableOrientationBtn.style.display = 'block';
  enableOrientationBtn.addEventListener('click', async () => {
    const permissionState = await DeviceOrientationEvent.requestPermission();
    if (permissionState === 'granted') {
      console.log("DeviceOrientation permission granted.");
      enableOrientationListening();
      enableOrientationBtn.style.display = 'none';
    } else {
      console.warn("DeviceOrientation permission denied.");
    }
  });
} else {
  // No permission needed or not supported
  enableOrientationListening();
}

function enableOrientationListening() {
  window.addEventListener('deviceorientation', (event) => {
    deviceHeading = calculateDeviceHeading(event.alpha);
  }, true);
  console.log("DeviceOrientation listening started.");
}

(function() {
  console.log("Starting AR demo setup.");

  // Target location
  const targetLat = 28.3375;
  const targetLon = -81.463333;

  let currentLat, currentLon;

  let deviceHeading = 0;  // Device heading (0 = North)
  // We'll define bearing as the direction of the target from our position (0 = North).
  let bearing = 0;

  // Access camera
  (async function initCamera() {
    try {
      console.log("Requesting camera access...");
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "environment" }, 
        audio: false 
      });
      const video = document.getElementById('videoElement');
      video.srcObject = stream;
      await new Promise(resolve => video.onloadedmetadata = resolve);
      console.log("Camera loaded successfully.");
      infoEl.textContent = "Camera loaded. Getting location...";
      initLocation();
    } catch (err) {
      console.error("Error accessing camera:", err);
      infoEl.textContent = "Error accessing camera: " + err.message;
    }
  })();

  const infoEl = document.getElementById('info');

  // Get initial position
  async function initLocation() {
    try {
      console.log("Requesting initial geolocation...");
      const pos = await getPosition();
      currentLat = pos.coords.latitude;
      currentLon = pos.coords.longitude;
      console.log("Initial position:", currentLat, currentLon);
      infoEl.textContent = "Location acquired. Setting up 3D...";
      initThreeJS();
      watchLocation();
    } catch (e) {
      console.error("Geolocation error:", e);
      infoEl.textContent = "Geolocation error: " + e.message;
    }
  }

  function getPosition() {
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      });
    });
  }

  // Watch position updates
  function watchLocation() {
    navigator.geolocation.watchPosition(pos => {
      currentLat = pos.coords.latitude;
      currentLon = pos.coords.longitude;
      updateInfo();
    }, err => {
      console.warn("Geolocation watch error:", err);
    },{
      enableHighAccuracy: true,
      maximumAge: 0,
      timeout: 15000
    });
  }

  // Three.js setup
  let scene, camera, renderer, arrowGroup;

  function initThreeJS() {
    const container = document.getElementById('threeContainer');
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0,0,0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);

    createArrow();
    animate();
    updateInfo();

    console.log("3D scene set up complete.");
  }

  // Create a more complex arrow so it's always visible
  function createArrow() {
    arrowGroup = new THREE.Group();

    // Shaft: a box along Z-axis
    // We'll rotate after creation to align with -Z
    const shaftGeometry = new THREE.BoxGeometry(0.1,0.1,2);
    const shaftMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});
    const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
    shaft.position.z = -1; // so front is at -2 and back at 0 along Z
    arrowGroup.add(shaft);

    // Arrowhead: cone pointing further along -Z
    const headGeometry = new THREE.ConeGeometry(0.2,0.5,16);
    const headMaterial = new THREE.MeshBasicMaterial({color:0xff0000});
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.z = -2.5; 
    head.rotation.x = Math.PI; // cone by default points +Y, rotate so it points -Z
    arrowGroup.add(head);

    // Tail fins: two flat boxes at the back to ensure visibility from behind
    const finGeometry = new THREE.BoxGeometry(0.5,0.01,0.5);
    const finMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});
    const fin1 = new THREE.Mesh(finGeometry, finMaterial);
    fin1.position.z = 0.25;
    fin1.position.y = 0.25;
    arrowGroup.add(fin1);

    const fin2 = fin1.clone();
    fin2.position.y = -0.25;
    arrowGroup.add(fin2);

    // The arrow currently points along the Z axis.
    // We want it to point along -Z for "North".
    // By default, we created it with the shaft along Z.
    // Actually, box by default is aligned so Z is its length direction.
    // No rotation needed for that. The head we rotated to point -Z already.
    // The entire arrow now points from camera towards negative Z.

    arrowGroup.position.set(0,0,-3);
    scene.add(arrowGroup);
  }

  function toRadians(deg) { return deg * Math.PI / 180; }

  function calculateBearing(lat1, lon1, lat2, lon2) {
    const dLon = toRadians(lon2 - lon1);
    lat1 = toRadians(lat1);
    lat2 = toRadians(lat2);

    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    let brng = Math.atan2(y, x);
    brng = (brng * 180 / Math.PI + 360) % 360; 
    return brng;
  }

  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000; // meters
    const φ1 = toRadians(lat1), φ2 = toRadians(lat2);
    const Δφ = toRadians(lat2 - lat1);
    const Δλ = toRadians(lon2 - lon1);
    const a = Math.sin(Δφ/2)*Math.sin(Δφ/2) + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  function updateInfo() {
    bearing = calculateBearing(currentLat, currentLon, targetLat, targetLon);
    const distanceMeters = haversineDistance(currentLat, currentLon, targetLat, targetLon);
    const distanceFeet = distanceMeters * 3.28084;
    infoEl.textContent = 
      `Lat: ${currentLat.toFixed(5)}, Lon: ${currentLon.toFixed(5)}, Bearing: ${bearing.toFixed(2)}°, Distance: ${distanceFeet.toFixed(1)} ft`;
  }

  // Convert device orientation alpha to heading (0 = North)
  function calculateDeviceHeading(alpha) {
    // alpha: 0 = device pointing East, 90 = South, 180 = West, 270 = North (on some devices)
    // Different devices interpret alpha differently. We want 0 = North.
    // Typically alpha=0 means magnetic North on many devices, but this can vary.
    // We'll assume alpha=0 means the device is facing North.
    // If alpha=0 means East on your device, you may need to adjust. Let's try a simple transform:
    // Let's assume alpha=0 means device faces "magnetic North" (common on iOS Safari after permission)
    // We'll trust alpha as heading from North.

    return alpha; // Assuming alpha in degrees, with 0 = North.
  }

  function animate() {
    requestAnimationFrame(animate);

    // final rotation = bearing - deviceHeading
    // bearing: 0 = target North, 90 East, etc.
    // deviceHeading: 0 = North, 90 East, etc.
    // if bearing=90 (target East), deviceHeading=0 (you face North),
    // arrow should point East: rotation = 90 degrees to the right.
    const finalRotation = bearing - deviceHeading;
    arrowGroup.rotation.y = -toRadians(finalRotation);

    renderer.render(scene, camera);
  }
})();
</script>
</body>
</html>